{"datasets":[{"meta":{"id":"JSKwa7CCs75tPqXRToLj4","projectId":"wHxyeNIJLo2ZrylGbkznh","name":"Node Summaries","description":""},"data":{"id":"JSKwa7CCs75tPqXRToLj4","rows":[{"id":"fFUHwkCQkvYepcKvI8QS7","data":["The SubGraphNode in Rivet is a specialized node designed to execute another graph within an AI agent's workflow, allowing for modular and reusable graph structures. It facilitates the integration of existing graphs by defining inputs and outputs through Graph Input and Graph Output nodes, enabling users to pass data seamlessly between different graph components. The node can be configured to use error outputs, providing robust error handling during execution. This makes the SubGraphNode particularly useful for creating complex AI workflows that require the execution of multiple interconnected graphs, enhancing both the organization and reusability of AI prompt chains."]},{"id":"e2GDkyB6y6rT-SloWACE4","data":["The `LoadDatasetNode` is a component within the Rivet framework designed to facilitate the loading of datasets using a specified dataset ID. This node allows users to input a dataset ID, either through a direct input or by selecting from available datasets, and retrieves the corresponding dataset from a dataset provider. Upon successful retrieval, it outputs the dataset as an array of objects along with the dataset ID. If the specified dataset does not exist, the node throws an error, ensuring robust error handling. This functionality is essential for integrating data-driven decision-making into AI agents, enabling them to access and utilize datasets dynamically during their processes."]},{"id":"IOxNPP_5R1E1zaX6LWbQb","data":["The BooleanNode in Rivet is a versatile component designed to output a boolean constant or convert an input value into a boolean. It allows users to either define a fixed boolean value or utilize an input port to dynamically determine the boolean output based on incoming data. The node features a toggle editor for easy configuration of its value and supports optional input, making it useful for scenarios where boolean logic is needed, such as condition checks, flow control in AI prompt chains, or decision-making processes within AI agents. By providing clear output definitions and an intuitive interface, the BooleanNode enhances the flexibility and functionality of AI agent development within the Rivet environment."]},{"id":"TG3itS3Y8tXKjCqBKXGXt","data":["The Slice Node in Rivet is designed to extract a portion of an array based on specified start and count parameters, making it a valuable tool for manipulating lists. It allows users to define a starting index and the number of elements to slice from an input array, with options to either use fixed values or dynamic inputs for these parameters. This functionality is particularly useful for scenarios where you need to process or analyze specific segments of data within larger datasets, enabling efficient data handling and extraction in AI agent workflows."]},{"id":"cy1fJzQEVWxYz_ahF6lAM","data":["The `HttpCallNode` in Rivet is a specialized component designed for making HTTP requests within AI agent workflows. It allows users to configure various parameters such as the HTTP method (GET, POST, PUT, DELETE), URL, headers, and body of the request, enabling flexible interactions with web APIs. The node supports both binary and textual responses, and it can handle JSON parsing automatically based on the response content type. Additionally, it provides options for error handling on non-200 status codes and integrates seamlessly into the visual, graph-based interface of Rivet, making it an essential tool for developers looking to enhance their AI agents with external data retrieval capabilities."]},{"id":"-WFm_PpisggdqUsACgkx4","data":["The GPT Function Node in Rivet is designed to define a callable function for a GPT language model, allowing it to execute specific tasks based on structured inputs and outputs. This node facilitates the integration of user-defined functions into AI prompt chains by enabling developers to specify the function's name, description, and schema, which outlines the expected structure of input data. With options for strict parameter enforcement and the ability to dynamically generate input fields based on the provided schema, the GPT Function Node enhances the flexibility and capability of AI agents. It processes inputs to create a structured function that the language model can invoke, making it a powerful tool for developers looking to extend their AI applications with customized functionalities."]},{"id":"R7CuB0ej2KjI0EafKLEkc","data":["The Match Node in Rivet is a versatile component designed for evaluating input strings against a series of regular expressions, allowing users to define multiple cases that dictate the output based on the input's match status. It can be configured to either return the first matching case or all matches, depending on the exclusive setting. This functionality is particularly useful for scenarios such as input validation, conditional branching in AI workflows, or processing text data where different responses are required based on specific patterns. The node outputs the corresponding value for the matched case while providing a fallback for unmatched inputs, making it an essential tool for implementing logic and control flow in AI agent designs."]},{"id":"tZ_GX5uLd_G5jLxluwuI5","data":["The Destructure Node in Rivet is a specialized node designed for extracting values from complex objects using JSONPath notation. It allows users to specify one or more JSONPath expressions, each corresponding to an output port of the node. When provided with an input object, the node processes the specified paths and outputs the matched values, enabling developers to easily navigate and manipulate structured data within their AI prompt chains. This functionality is particularly useful for scenarios where data needs to be dissected for further processing or analysis, enhancing the flexibility and capability of AI agents created using the Rivet IDE."]},{"id":"fYyG9rArUM37A7qN-l3uy","data":["The Extract Object Path Node is a component in the Rivet IDE designed to extract values from complex data structures using JSONPath notation. It allows users to specify a path to navigate through an input object, retrieving a single match or all matches that correspond to the given path. The node features an optional input for the path, enabling dynamic extraction based on user-defined criteria. Its output includes the first match found and an array of all matches, making it particularly useful for processing and analyzing structured data formats like JSON. This node enhances the flexibility and efficiency of AI agent workflows by enabling precise data manipulation and retrieval."]},{"id":"-Q9mcnWBfWoy-zbbybWdC","data":["The Pop Node is a versatile component in the Rivet IDE designed for manipulating arrays by extracting elements from them. It allows users to pop either the first or the last item from an input array, depending on the configuration set in the node's properties. The node outputs the extracted item as well as the remaining elements of the array, making it useful for tasks that require dynamic array manipulation, such as processing lists in AI workflows or managing data sequences. With its toggle feature, users can easily switch between popping from the front or the back of the array, enhancing the flexibility of data handling in AI agent designs."]},{"id":"W3ab1F7qeg7j71tT9b0v6","data":["The Join Node in Rivet is designed to take an array of strings and concatenate them into a single string using a specified delimiter, which can be customized by the user. This node features a toggle option to flatten nested arrays, allowing for more flexible input handling. Users can define the joining string, with the default being a newline character, and can choose to input a different joining string dynamically. The Join Node is particularly useful for scenarios where multiple text inputs need to be combined into a cohesive output, such as formatting messages, generating reports, or preparing data for further processing in AI workflows."]},{"id":"y-j2pcrmOT7oB2bxM749V","data":["The Delegate Function Call Node in Rivet is designed to handle function calls by delegating them to specific subgraphs based on the function name provided in the call. It allows developers to define multiple handlers that map function names to their corresponding subgraph identifiers, enabling flexible and dynamic routing of function calls. If a function call does not match any defined handler, it can be directed to an \"unknown handler,\" ensuring that the system remains robust even when unexpected inputs are encountered. This node is particularly useful for creating modular AI agents that can process a variety of function calls efficiently, facilitating a clean and organized approach to managing complex AI interactions within the Rivet framework."]},{"id":"SYAauHVX63t5H42lDal9D","data":["The Play Audio Node in Rivet is designed to facilitate the playback of audio data within AI agent workflows. It allows users to input audio data, which can then be processed and played through an audio provider in the application's context. This node features a straightforward input-output structure, where it accepts audio data as input and returns the same data after playback, ensuring seamless integration within complex AI prompt chains. The Play Audio Node is particularly useful for applications that require audio feedback, such as interactive voice agents or multimedia presentations, enhancing user engagement through auditory experiences."]},{"id":"L2ScUWgRqOTxtDfQBLlMV","data":["The Shuffle Node in Rivet is designed to randomly reorder the elements of an input array, providing a shuffled output array. This node is particularly useful in scenarios where a randomized arrangement of data is required, such as in games, simulations, or when testing algorithms that rely on varying input sequences. By accepting an array as input and returning the shuffled version, the Shuffle Node enhances the flexibility and functionality of AI prompt chains, enabling developers to incorporate randomness into their AI agents' decision-making processes or data handling."]},{"id":"nFh7Kho3kv7haIV_oeWd7","data":["The Vector Store Node is a component within the Rivet framework designed for storing vectors alongside associated data in a specified vector database integration, such as Pinecone. This node accepts inputs including a vector, optional collection ID, integration type, and additional data, allowing users to dynamically configure its behavior. It processes the inputs to store the vector and its related data in the configured database, facilitating later retrieval. With its visual interface and integrated debugging capabilities, the Vector Store Node simplifies the management of vector data, making it a valuable tool for developers working on AI applications that require efficient data storage and retrieval mechanisms."]},{"id":"5ZxBBCSyk3rkTsI-x1Ri3","data":["The Chunk Node in Rivet is designed to split input text into an array of chunks based on a specified token count, making it particularly useful for processing large text inputs in AI applications. It allows users to define the number of tokens per chunk, the overlap percentage between chunks for redundancy, and the model to be used for tokenization. The node outputs several useful data points, including the array of chunks, the first and last chunks, their respective indexes, and the total count of chunks created. This functionality is essential for efficiently managing and analyzing large text data, ensuring that AI models can handle inputs without exceeding token limits while maintaining context through overlapping segments."]},{"id":"S9auIshZScS9t92rzbVQH","data":["The Context Node in Rivet is designed to retrieve values from the graph's context using a specified identifier, effectively acting as a \"global graph input\" that allows consistent access to values across different graphs or subgraphs. It is configurable, enabling users to define the data type and optionally provide a default value if the desired context value is not found. This node enhances the flexibility and reusability of AI prompt chains by allowing dynamic data retrieval based on the context, which is particularly useful in complex scenarios where multiple agents or processes may need to share and utilize the same data seamlessly."]},{"id":"WAE8KCklsiIQ6euG05uXO","data":["The Prompt Node in Rivet serves as a versatile component for generating chat messages within AI agent workflows. It allows users to define the type of message (system, user, assistant, or function) and customize the prompt text using interpolation, enabling dynamic content generation based on input values. The node can also handle function calls, making it suitable for integrating external functionalities, and it provides options for calculating token counts for the generated messages. With its ability to output structured chat messages, including optional metadata like names and cache breakpoints, the Prompt Node is essential for creating interactive and context-aware AI agents that can seamlessly communicate within various applications."]},{"id":"lLunx3hLQN2fyTxGyoT-7","data":["The UrlReferenceNode in Rivet is designed to define a reference to a URL or convert a string input into a URL reference, making it particularly useful for creating dynamic links in AI prompt chains. This node allows users to specify a URL directly or utilize an input string as a URL, enabling flexibility in how URLs are handled within the graph. The output of this node is an object containing the URL reference, which can be integrated with other nodes, such as the Assemble Message node, to facilitate the inclusion of URLs for attachments or images in AI-generated content. Additionally, the node features a user-friendly editor for easy configuration and real-time debugging capabilities to monitor its functionality within the overall AI agent workflow."]},{"id":"vQnwqhKe-2jSYCGKZzB0x","data":["The Coalesce Node in Rivet is a logic-based node that takes in multiple input values and outputs the first available value that exists, effectively consolidating branches in a decision-making process. It is particularly useful for scenarios where you want to prioritize certain inputs over others, such as after a Match node, ensuring that the first non-null input is returned. Additionally, the Coalesce Node can handle control-flow exclusions, allowing it to operate seamlessly in complex AI prompt chains by managing situations where no valid input is present. This functionality makes it an essential tool for creating robust and flexible AI agents that can adapt to varying input conditions."]},{"id":"3vQ3e3vwOZ8QoxRXfegYJ","data":["The `AppendToDatasetNode` is a specialized node within the Rivet framework designed to facilitate the appending of data rows to a specified dataset. This node allows users to input various types of data, including strings, arrays of strings, and vector embeddings, which can be associated with each row. It provides the option to specify a unique identifier for the row, generating one randomly if not provided. The node integrates seamlessly with Rivet's visual graph-based interface, enabling users to visually construct and manage their AI workflows. By utilizing this node, developers can effectively enrich their datasets with new information, making it a valuable tool for applications that require dynamic data management and storage in AI-driven projects."]},{"id":"wIGcsY5Ka9vJN8mFf7JPE","data":["The `RaiseEventNode` is a component within the Rivet IDE that allows users to trigger events within their AI agent workflows. It enables the user to specify an event name, which can either be a predefined string or dynamically provided through an input, along with associated data to be sent with the event. This functionality is particularly useful for creating interactive and responsive AI applications, as it facilitates communication between different parts of the system, such as triggering responses in other nodes or allowing external listeners to react to specific events. The node's design includes options for visual configuration and real-time debugging, enhancing the user's ability to manage complex event-driven behaviors within their AI projects."]},{"id":"xdP7ZQYXiBFL5QWRP2pOa","data":["The **Trim Chat Messages Node** is a specialized component within the Rivet IDE that processes an array of chat messages to ensure the total token count remains within a specified limit. It allows users to configure parameters such as the maximum token count and whether to remove messages from the beginning or the end of the array. This functionality is particularly useful for managing message chains in AI applications, ensuring that the input stays within the context limits of language models. By dynamically trimming chat messages, this node helps maintain efficient communication while preventing overflow issues in AI interactions."]},{"id":"rGBrJHs4VfzWZlk4E1RM-","data":["The `CreateDatasetNode` is a component of the Rivet IDE that facilitates the creation of a new dataset within an AI agent's workflow. It allows users to specify a unique Dataset ID and a Dataset Name as inputs. When processed, the node checks if a dataset with the given ID already exists; if not, it creates a new dataset with the provided metadata. This functionality is particularly useful for managing datasets dynamically within AI applications, enabling seamless integration and organization of data as the AI agent operates. The output of the node provides the Dataset ID, which can be used in subsequent nodes for further processing or analysis."]},{"id":"uSOXRpVErge-sn80K6dKz","data":["The Loop Controller Node in Rivet is designed to manage iterative processes within AI prompt chains, allowing users to define and control the flow of execution based on specified conditions. It enables the creation of loops by providing input ports for data and a \"continue\" control port to dictate whether the loop should proceed or break. Users can set a maximum number of iterations and specify actions to take when this limit is reached, such as breaking the loop or triggering an error. This node is particularly useful for scenarios where repeated processing of data is required, such as in simulations, batch processing tasks, or when implementing complex decision-making workflows that depend on previous iterations' outputs."]},{"id":"wRfdmGs8G_RYMrVDwXjkk","data":["The `GraphInputNode` is a component within the Rivet framework that defines an input for a graph, enabling users to pass in values when the graph is executed or to establish input ports for subgraphs. This node allows for the configuration of various attributes, including the input's ID, data type, and an optional default value. Users can also select from different editor types to tailor the user interface for editing the input value. During processing, the node retrieves the value from the graph's inputs or defaults to a specified value if none is provided, ensuring flexibility in handling different data types and accommodating scenarios where input may be absent. Overall, the `GraphInputNode` is essential for creating dynamic and interactive AI agent workflows in Rivet."]},{"id":"XYgpr4UrSRKca5mxn3yrA","data":["The Object Node in Rivet is designed to create structured objects from input values using a customizable JSON template. It allows users to define a template that incorporates dynamic input values, which are automatically escaped for safe insertion. This node is particularly useful for generating complex objects from multiple inputs, enabling users to easily format and manipulate data in a structured way. With its ability to interpolate values within the template and produce outputs as either individual objects or arrays of objects, the Object Node serves as a versatile tool for developers looking to streamline data handling in their AI agent workflows."]},{"id":"SlVX0FrUteaVJV2nuM-ED","data":["The Passthrough Node in Rivet is a simple yet versatile component designed to facilitate the flow of data within AI prompt chains by directly passing input values to their corresponding outputs without any modifications. This node is particularly useful for scenarios where data needs to be relayed from one part of the graph to another, allowing developers to maintain a clear flow of information while debugging or testing different configurations. With its dynamic input and output definitions based on connections, the Passthrough Node can adapt to various setups, making it an essential tool for managing data transfer in complex AI agent workflows."]},{"id":"o6BFdR-vOhQ39EDM9gt7u","data":["The `GetGlobalNode` is a specialized node within the Rivet IDE designed to retrieve global values that are shared across all graphs and subgraphs. It allows users to specify a variable ID, choose the data type of the value to be retrieved, and configure whether the value should be fetched on-demand or wait for its availability. This node can be particularly useful in scenarios where multiple agents or processes need to access and utilize shared data consistently, enabling dynamic and responsive AI behavior. It supports both immediate retrieval and deferred access, enhancing flexibility in managing global state within AI workflows."]},{"id":"I6mI5TEI0ugW26XhTEGiX","data":["The Compare Node in Rivet is a versatile logic node that enables users to perform various comparison operations between two input values, labeled as A and B. It supports a range of comparison functions, including equality checks (==, !=), relational comparisons (<, >, <=, >=), and logical operations (and, or, xor, nand, nor, xnor). Users can configure the node to either use a predefined comparison function or provide a custom function as an input. The output of the node is a boolean value indicating the result of the comparison, making it useful for decision-making processes within AI agent workflows, conditional branching, and logical evaluations in complex AI prompt chains. With its visual representation and live debugging capabilities, the Compare Node simplifies the integration of logical operations into AI applications."]},{"id":"D213W80MpIaHs0gfEsrsL","data":["The Array Node in Rivet is designed to create and manipulate arrays from input values, offering functionality to flatten nested arrays based on user-defined options. It allows users to dynamically connect multiple inputs, which can be either individual values or arrays. The node provides two main configurations: a standard flattening option that merges input arrays into a single array, and a deep flattening option that recursively flattens nested arrays. The output of the node includes the constructed array, its indices, and the length of the array, making it a versatile tool for both generating and merging arrays within AI prompt chains. This node is particularly useful for organizing and processing data in a structured manner, enhancing the capabilities of AI agents in handling complex data structures."]},{"id":"HN1HYhvhQo9OqIm51mSoq","data":["The Abort Graph Node in Rivet is a specialized node designed to terminate the execution of an AI prompt chain or graph immediately, allowing for controlled exits based on specific conditions. It provides the ability to abort the graph either successfully or with an error message, enabling developers to handle different scenarios during the execution flow. The node can be configured to take inputs that determine whether the abort is successful or erroneous, and it can output a custom error message if needed. This flexibility makes it a crucial component for managing the control flow in complex AI agent workflows, ensuring that processes can be halted gracefully when necessary."]},{"id":"4nvLCxsg9-kCLUEAqDFul","data":["The **Extract Markdown Code Blocks Node** is a specialized component within the Rivet IDE that enables users to extract code blocks from Markdown text inputs. Utilizing a regular expression, this node identifies and retrieves the first code block, all code blocks, and the programming languages associated with each block from the provided input string. It outputs three distinct values: the first matched code block as a string, an array of all matched code blocks, and an array of the corresponding languages. This functionality is particularly useful for developers and content creators who need to process and analyze code snippets embedded within Markdown documents, facilitating tasks such as code extraction, analysis, and transformation in AI-driven applications."]},{"id":"ZYbHc2F3wQWbfkmVAFl2v","data":["The Vector KNN (K-Nearest Neighbors) node in Rivet is designed to perform k-nearest neighbors searches on vector data stored within a configured vector database integration, such as Pinecone. By taking a vector as input, this node retrieves the k closest vectors along with their associated data, making it useful for applications in recommendation systems, similarity searches, and clustering tasks. It allows users to dynamically specify parameters such as the integration type, the number of neighbors (k), and the collection ID, enabling flexible and efficient data retrieval based on vector proximity."]},{"id":"8H4MadAXOrfnyPEuDef4O","data":["The Evaluate Node in Rivet is designed to perform mathematical operations on input values, allowing users to evaluate expressions and obtain results dynamically. It supports a variety of operations, including addition, subtraction, multiplication, division, exponentiation, modulus, and unary operations like absolute value and negation. The node can take one or two numeric inputs, depending on the selected operation, and can also accept an operation type as a string input for greater flexibility. This node is particularly useful for integrating mathematical calculations into AI workflows, enabling the creation of complex logic and data manipulations within the visual graph-based interface of the Rivet IDE."]},{"id":"j-ARO2y8yPb6umpjIPx0i","data":["The `UserInputNode` in Rivet is designed to prompt users for input during the execution of an AI graph, allowing for dynamic interaction within AI agent workflows. It can be configured to either use predefined questions or a single custom prompt, enabling flexibility in user engagement. The node outputs the user's responses, providing both answers only and a combined list of questions and answers. Additionally, it supports different rendering formats, such as preformatted text and markdown, enhancing the presentation of the user interface. This node is particularly useful for applications that require real-time user feedback or interaction, making it an essential component for creating responsive AI agents."]},{"id":"3dD66i3eLFkEv88nfA2yT","data":["The `DocumentNode` in Rivet is a specialized node designed for handling documents within AI agent workflows. It allows users to input various types of document data, including text and binary formats, and provides options to specify the media type, title, context, and whether citations should be enabled. This node can be particularly useful for integrating documents into AI processes, such as assembling messages or processing information, by facilitating the management and manipulation of document-related data. With its visual interface, users can easily configure input options and monitor the document's attributes, making it an essential component for applications that require document handling and processing in AI workflows."]},{"id":"Td8bAsWWqWqrR7vj80qKn","data":["The Assemble Prompt Node in Rivet is designed to dynamically compile an array of chat messages into a single prompt for use with Chat nodes. It allows users to input multiple messages, which can be either strings or chat message objects, and assembles them into a structured format. This node provides options to compute the token count of the resulting prompt and to designate the last message as a cache breakpoint, which is particularly useful for optimizing performance in AI interactions. By visually connecting this node within a graph, developers can easily manage and debug the flow of messages, making it an essential tool for creating complex AI agent interactions in Rivet."]},{"id":"Cmb9rvrqU7L2RIxAiLkTy","data":["The `GetDatasetRowNode` is a component within the Rivet IDE that enables users to retrieve a specific row from a dataset based on a provided dataset ID and row ID. This node is particularly useful for AI agents that require access to structured data, allowing them to dynamically pull in relevant information for processing or decision-making. The node features configurable inputs for both dataset and row IDs, supporting flexibility in how data is accessed. If the specified dataset or row does not exist, the node will throw an error, ensuring that users are promptly informed of any issues. Overall, this node facilitates efficient data handling within AI prompt chains, enhancing the capabilities of AI agents in data-driven applications."]},{"id":"H0XVxpYSzMa3_b8rQVc1b","data":["The `ToJsonNode` is a component in Rivet designed to convert input data into its JSON string representation. It offers functionality to toggle between indented and non-indented formats for better readability. This node requires an input of any data type and outputs the corresponding JSON string, making it useful for scenarios where data needs to be serialized for storage, transmission, or further processing in a JSON-compatible format. The node's visual interface allows users to easily integrate it into their AI prompt chains, facilitating the transformation of complex data structures into a widely-used format for APIs, databases, or other applications."]},{"id":"SK9HxYE7KiQvh0bauDD5D","data":["The `WaitForEventNode` is a specialized node within the Rivet framework designed to pause the execution of an AI agent until a specified event is triggered. It allows users to configure an event name, which can be either set directly or provided via input, enabling flexibility in how events are managed within prompt chains. When the node is activated, it listens for the designated event, and upon its occurrence, it captures any associated data. This functionality is particularly useful for creating interactive AI agents that need to respond to user actions or other external triggers, facilitating complex workflows that rely on real-time events."]},{"id":"QPGyaRosebPfH30NlJ8Ba","data":["The AudioNode in Rivet is designed to handle audio data within AI agent workflows, enabling users to define and manipulate audio samples for integration with other nodes. This node allows for the input of audio files through a file browser, supporting various media types such as WAV, MP3, and OGG. It features options for users to either directly input binary audio data or reference external audio data stored in a project. The AudioNode processes the input data and outputs it in a structured format, making it suitable for tasks that involve audio processing, playback, or analysis in AI applications. Its visual representation in the Rivet editor facilitates easy configuration and debugging, enhancing the development experience for AI agents that utilize audio content."]},{"id":"YM4kDBUraQqvp8n_qVP6A","data":["The `GetAllDatasetsNode` is a specialized node within the Rivet framework designed to retrieve all datasets associated with a specific project. When executed, it queries a `datasetProvider` to fetch the datasets linked to the project's metadata ID. If no datasets are found, it returns an empty array, ensuring that the output is always consistent. This node is particularly useful for AI agents that require access to available datasets for processing or analysis, enabling seamless integration and management of data within complex AI prompt chains and workflows."]},{"id":"4Ab1wp16GnNTOYmKYJAoi","data":["The **Get Embedding Node** in Rivet is designed to generate vector embeddings for input text using AI integrations, primarily OpenAI. It allows users to specify various parameters such as the integration type, model, and dimensions of the embedding, either through predefined settings or dynamic inputs. This node processes the input text and outputs a vector representation, which can be utilized in various applications, including vector storage and nearest neighbor search functionalities. Its flexibility in configuration makes it an essential tool for developers looking to enhance AI-driven applications with advanced text processing capabilities."]},{"id":"H7yqeascU5-aYdSfCohCz","data":["The Read File Node in Rivet is designed to read the contents of a specified file and output it as either a string or binary data, depending on the user's configuration. It offers flexibility through options such as using a path input, reading as binary, and handling errors for missing files. When integrated into an AI agent's prompt chain, this node can facilitate tasks that require file input, such as processing text files for natural language tasks or reading binary files for data analysis. The node's ability to handle errors gracefully allows for robust implementations, making it a valuable tool for developers working with file-based data in their AI applications."]},{"id":"lPdgh27W_sEFUrPiziZWF","data":["The `GraphOutputNode` is a specialized node in the Rivet IDE designed to represent individual outputs of a graph, facilitating the management of data flow within AI prompt chains. This node allows users to define an output value, which is then included as part of the overall output of the graph. It features input and output definitions for handling data, customizable editors for setting the output ID and data type, and a body description that provides context on its functionality. The node also supports control flow management by distinguishing between regular outputs and control-flow-excluded values, ensuring that the output reflects the current state of the graph accurately. This makes the `GraphOutputNode` essential for structuring and retrieving results from complex AI processes visually."]},{"id":"qppx3239UrIpsSsBRCQTS","data":["The `ChatNode` in Rivet is a versatile component designed for generating conversational responses using AI models, particularly from the OpenAI API. It allows users to configure various parameters such as model selection, temperature, top-p sampling, maximum token limits, and response formats, enabling fine-tuning of the AI's output. The node can handle both text and audio modalities, making it suitable for applications that require rich interaction, including chatbots and voice assistants. Additionally, it supports features like function calling, response caching, and usage statistics, making it a powerful tool for developers looking to integrate AI-driven conversational capabilities into their applications."]},{"id":"IHAdRHozYR_TI0ph6E3R9","data":["The Extract Regex Node in Rivet is designed to extract specific data from input text using a configurable regular expression. This node allows users to define a regex pattern that can include capture groups, enabling the retrieval of particular segments of text from the input string. It features options for error handling, such as throwing an error when no matches are found, and supports multiline input processing. The node outputs the captured groups as well as an array of all matches found, along with boolean indicators to signal the success or failure of the extraction process. This functionality is particularly useful for tasks such as data parsing, text analysis, and any scenario where structured information needs to be extracted from unstructured text."]},{"id":"c5q5y2dBewG1V4dMdlBKm","data":["The Number Node in Rivet is a versatile component designed for handling numerical data within AI prompt chains. It can either output a constant number or convert an input value into a number, offering flexibility in data processing. Users can configure the node to round the output to a specified number of decimal places, enhancing precision as needed. This node is particularly useful in scenarios where numerical manipulation is required, such as calculations, data formatting, or preparing numerical inputs for further processing in AI workflows. The node's visual representation and real-time processing capabilities make it easy to integrate and debug within the graph-based interface of Rivet."]},{"id":"Uc_wfPAjqNtb5HwBbSOs-","data":["The Comment Node in Rivet is a specialized node designed for adding annotations or notes within a graph without performing any functional operations. It allows users to include descriptive text, which can be formatted in Markdown, alongside customizable visual attributes such as color and background color. This node serves as a valuable tool for enhancing the clarity and organization of complex AI prompt chains by providing context and explanations directly within the visual interface, making it easier for developers to understand the purpose and flow of the graph at a glance. The Comment Node is particularly useful in collaborative environments where multiple users may need to reference or comprehend the logic behind various components of the AI agent."]},{"id":"iHkM2LdXwvhVH3dhCRJLz","data":["The `ReplaceDatasetNode` is a component in the Rivet IDE that facilitates the replacement of data within a specified dataset. It allows users to input new data, which can be in the form of an array of strings or an array of `DatasetRow` objects, and replaces the existing dataset with this new data. If no data is provided, the node will clear the dataset instead. This node is particularly useful for dynamically updating datasets during the execution of AI agents, enabling seamless data management and manipulation within the visual prompt chains created in Rivet. Additionally, it provides options for selecting the dataset ID, ensuring that users can easily target and modify the correct dataset in their workflows."]},{"id":"e2go1E5zH-rbYu0cZhb4q","data":["The External Call Node in Rivet serves as a bridge between the Rivet graph and external functions defined within the host project. This node allows users to invoke functions dynamically by specifying the function name and passing arguments, either directly or through input. It features options for error handling, enabling the user to choose whether to capture errors as output or to throw exceptions. This functionality is particularly useful for integrating Rivet's AI capabilities with existing application logic, allowing for seamless execution of external processes while maintaining control over the data flow and error management in AI agent workflows."]},{"id":"03j3m56fTG3YDs3uZda0I","data":["The Filter Node in Rivet is designed to process an array of values alongside a corresponding array of boolean indicators, effectively filtering the input array based on the truthiness of the boolean values. When executed, it takes in two inputs: an array and a boolean array of the same length, and returns a new array containing only the elements from the input array where the corresponding boolean value is true. This functionality is particularly useful for scenarios where selective data extraction is required, allowing users to efficiently manage and manipulate datasets based on specific criteria. The node's visual representation and real-time processing capabilities make it an intuitive choice for developers working with complex data flows in AI agent development."]},{"id":"NvojsE7xnxUsKIA3Y1ZA0","data":["The Set Global Node in Rivet is designed to define and manage global variables that can be accessed across multiple graphs and subgraphs within an AI agent's workflow. This node allows users to set a global value by specifying an ID and a data type, which can be configured through its editor interface. When executed, the node takes an input value, saves it as a global variable associated with the specified ID, and also retrieves the previous value of that global variable. This functionality is particularly useful for maintaining state or sharing data between different parts of an AI agent's operation, enabling more complex and interconnected behaviors in AI prompt chains."]},{"id":"umy_gxpnfE490in76CY61","data":["The Code Node in Rivet is a versatile component that allows users to execute JavaScript code within an AI agent's workflow. It provides a customizable interface where developers can define input and output names, enabling the seamless integration of dynamic logic into AI prompt chains. The node accepts inputs as an object, processes them through user-defined JavaScript code, and returns outputs that must match the specified output names. This functionality makes the Code Node ideal for scenarios where complex computations, data manipulations, or conditional logic are required, enhancing the overall capabilities of AI agents in Rivet's visual programming environment. Additionally, it supports error handling for missing outputs, ensuring robust and reliable execution within the AI framework."]},{"id":"ZZ8koA4y_atSKH4daxE3y","data":["The ImageNode in Rivet is designed to facilitate the integration and processing of static images within AI agent workflows. This node allows users to define an image by either providing binary data directly or referencing existing image data stored in the project. It supports various media types, including PNG, JPEG, and GIF, which can be selected through a dropdown interface. The ImageNode processes the input data to convert binary formats into image types, enabling seamless use of images in conjunction with other nodes in the AI prompt chains. Its functionality is particularly useful for applications that require image manipulation or display as part of their AI-driven processes."]},{"id":"V9ab7wi2WPzSG71yjdVZF","data":["The If/Else Node in Rivet is a logic-based component that facilitates conditional processing within AI prompt chains by evaluating a given condition and directing the flow of data based on its truthiness. It accepts three inputs: a condition (the \"If\" input), a value to output if the condition is true (the \"True\" input), and a value to output if the condition is false (the \"False\" input). If the condition is truthy, the node passes the true value through its output; otherwise, it passes the false value. This node also handles cases where input ports are unconnected, allowing for flexible graph designs. It is particularly useful for controlling the flow of data in complex AI workflows, enabling developers to implement branching logic effectively."]},{"id":"DwkdHce3seUsr0FQMi_-u","data":["The Hash Node in Rivet is a functional component designed to compute cryptographic hashes of input strings using various algorithms, including MD5, SHA-1, SHA-256, and SHA-512. This node allows users to select their desired hashing algorithm via a dropdown interface and processes the input string to produce a hashed output. It is particularly useful for scenarios that require data integrity verification, password hashing, or generating unique identifiers from input data. By visually integrating this node into AI prompt chains, developers can easily incorporate hashing functionality into their AI applications, enhancing data security and management capabilities."]},{"id":"Yrwk-M21nBY0wgv0GzN7K","data":["The `ToYamlNode` is a component of the Rivet IDE that converts input objects into YAML (YAML Ain't Markup Language) text format. This node accepts an object as input and processes it to produce a string output in YAML format, making it useful for scenarios where structured data needs to be represented in a human-readable format. It is particularly beneficial for developers working with configuration files, data serialization, or any context where YAML is preferred for its readability and simplicity. The node features a user-friendly interface that provides real-time feedback and debugging capabilities, ensuring that users can easily visualize and troubleshoot their data transformations."]},{"id":"2FzI-ytVSiie378V7Kita","data":["The Random Number Node in Rivet is designed to generate random numbers based on user-defined parameters. It allows users to specify minimum and maximum values, with options to include integers or floats, and to determine whether the maximum value is inclusive or exclusive. This node is useful for a variety of applications, such as simulations, gaming, or any scenario where randomization is needed within a specified range. The node's flexibility in configuration, including the ability to accept input values for the minimum and maximum thresholds, makes it a versatile tool for creating dynamic and unpredictable outputs in AI agent workflows."]},{"id":"fJrRW6QFB3L-koRCsJ_Lt","data":["The Assemble Message Node in Rivet is designed to create a single chat message by combining multiple parts, accommodating various data types such as text, images, and documents. This node is particularly useful for assembling messages in multimodal AI applications, allowing developers to specify the message type (system, user, assistant, or function) and optionally include a Tool Call ID for function messages. By connecting different input parts, users can construct complex messages that can be processed by AI agents, facilitating rich interactions and enhancing the overall functionality of AI-driven applications. The node also supports real-time monitoring and debugging, making it easier to ensure the correctness of the assembled messages."]},{"id":"sRkt_w-ddOjti-xEWGtk4","data":["The `ListGraphsNode` is a specialized node within the Rivet framework designed to retrieve and list all graphs present in a project. It outputs two key data types: an array of graph references, which includes the IDs and names of the graphs, and an array of graph names. This node is particularly useful for developers who need to dynamically access and manage multiple graphs within their AI agent configurations, enabling them to easily reference and utilize various graph components in their projects. By integrating this node into a graph chain, users can streamline workflows that require awareness of available graphs, facilitating better organization and execution of AI tasks."]},{"id":"VXZYMP6Cz64O-ibZewbhP","data":["The `TextNode` in Rivet is a versatile component designed for generating and manipulating text strings, enabling users to create dynamic outputs through interpolation. It allows for the inclusion of input variables within the text using a templating syntax (e.g., `{{input}}`), making it suitable for scenarios where personalized or context-specific responses are needed, such as crafting AI-generated messages or responses based on user inputs. The node provides a simple interface to define inputs and outputs, supports custom and code editors for enhanced usability, and features live debugging capabilities, ensuring that users can easily test and refine their text generation logic within AI agent workflows."]},{"id":"6u5HesTjmzxNbyBZ6fzJ8","data":["The Extract JSON Node in Rivet is designed to find and parse JSON objects from a given input string. It accepts a string input and attempts to extract the first valid JSON object, returning it as an output. If successful, the parsed object is provided through the output port, while a \"No Match\" port is used to indicate when no valid JSON is found. This node is particularly useful for scenarios where data is received in a string format that may contain JSON, allowing developers to seamlessly integrate JSON parsing capabilities into their AI agent workflows. Its robust error handling also ensures that even if the initial parsing attempt fails, it will try to identify and extract a JSON object from the input string using a more manual approach."]},{"id":"LDpUtYWu1YuO9CXYCcIB-","data":["The **Read Directory Node** is a component of the Rivet Integrated Development Environment designed for creating AI agents. This node facilitates the reading of a specified directory's contents, allowing users to retrieve an array of filenames within that directory. It offers configurable options such as whether to search recursively, include subdirectories, apply filters using glob patterns, and determine the output paths' format (relative or absolute). The node can be integrated into AI prompt chains to streamline file operations, making it particularly useful for applications that require directory management, file processing, or data extraction from file systems. Through its input and output definitions, users can dynamically control the parameters for directory reading, enhancing the flexibility and functionality of their AI agents."]},{"id":"VIRk9iXQeVgYsHkRPcp2K","data":["The Split Node in Rivet is designed to split a given string into an array of substrings based on a specified delimiter. This node allows users to define the delimiter either as a fixed string or dynamically through input, and it supports regular expression delimiters for advanced splitting scenarios. It features a user-friendly toggle for enabling regex usage and provides a clear interface for configuring the delimiter. The output of the node is an array of strings, making it useful for tasks such as parsing text data, processing user input, or transforming structured data formats where string manipulation is required."]},{"id":"NxDvijrSNnEU06ZuKyjjG","data":["The Chat Loop Node in Rivet is designed to facilitate interactive conversations between users and an AI model in a structured manner. It initiates a chat session by sending a user-defined prompt to the AI, capturing the AI's responses, and prompting the user for input in a continuous loop until the user decides to end the conversation. The node maintains a history of the entire conversation, allowing for contextually relevant interactions. It supports different rendering formats, such as plain text and markdown, making it versatile for various applications. This node is particularly useful for creating chatbots, virtual assistants, or any application requiring dynamic user interaction with an AI agent."]},{"id":"9YkNUuMPBqpl3Y-4XoEtw","data":["The Graph Reference Node in Rivet is designed to facilitate the referencing of other graphs within an AI agent's workflow. This node allows users to either input a graph's name or ID to obtain a reference to it, which can then be utilized in conjunction with a Call Graph node to invoke the referenced graph's functionality. It features dynamic input options, enabling users to select whether to use a graph ID or name for referencing. The node outputs a graph reference object that contains the graph's ID and name, making it a versatile tool for managing complex AI prompt chains by enabling modular graph execution and enhancing the overall organization of AI agent workflows."]},{"id":"rQULcmTdqsAVsYc0BmQn2","data":["The ChatNode is a component within the Rivet IDE that facilitates interactions with large language models (LLMs) through a chat interface. It allows users to make calls to GPT and other OpenAI-compatible APIs, enabling the integration of conversational AI capabilities into their projects. The node supports customizable inputs, including a system prompt for contextual guidance and a prompt input for sending messages or strings to the model. With its visual editor, users can easily configure the node's settings and monitor interactions, making it a powerful tool for creating dynamic and context-aware AI-driven applications."]},{"id":"JJQF5569oFymxzTqlSVna","data":["The Race Inputs Node in Rivet is designed to handle multiple input values and outputs the result of the first input that completes, effectively canceling any remaining inputs. This functionality is particularly useful in scenarios where multiple asynchronous operations may be initiated, and only the fastest response is needed, such as in competitive queries or time-sensitive tasks. The node dynamically determines the number of input ports based on the connections, allowing it to adapt to varying input scenarios. By leveraging this node, developers can streamline their AI agent's decision-making process by prioritizing the quickest responses while managing potential delays from slower inputs."]},{"id":"oxv7qt7MR1DPKRxSJcjuy","data":["The `ReadAllFilesNode` is a component of the Rivet IDE that facilitates the reading of all files within a specified directory, offering flexibility through various configurations such as recursive reading, filtering by glob patterns, and handling of ignored files. It allows users to choose whether to read files as binary or text and can be set to throw errors for missing files. The node outputs an array of objects, each containing the file path and its corresponding content, making it ideal for tasks that involve file manipulation, data processing, or content extraction from directories in a visual and user-friendly manner."]},{"id":"BsMeVnT_85ZsouqphfIKA","data":["The Call Graph Node in Rivet is a specialized component designed to invoke and execute another graph within the Rivet framework, allowing for modular and dynamic AI agent designs. This node takes a reference to a target graph and a set of inputs, processes them, and returns the outputs generated by the called graph. It features an optional error output mechanism, which can capture and return error messages if the graph execution fails. This functionality is particularly useful for creating complex AI workflows where different graphs can be called based on conditions or inputs, enabling developers to build sophisticated AI agents with reusable components while maintaining clear data flow and error handling."]},{"id":"hPtxs9E24s3234-qEneYv","data":["The Delay Node in Rivet is designed to introduce a specified delay in the execution of AI prompt chains, allowing for controlled timing in the flow of data between nodes. This node can be configured to accept a delay duration either as a fixed value or as an input from another node, enabling dynamic adjustments during runtime. When invoked, the Delay Node pauses execution for the defined duration before passing the input values to the output without any modifications. This functionality is particularly useful in scenarios where timing is critical, such as coordinating responses in chatbots, managing rate limits in API calls, or simulating real-time interactions in AI applications."]},{"id":"PBuAvXn8qFNCYNZ5G6YEM","data":["The Dataset Nearest Neighbors Node is a component within the Rivet framework designed for finding the k nearest neighbors in a specified dataset based on a given embedding. This node allows users to input an embedding vector and optionally specify a dataset ID and the value of k, which represents the number of nearest neighbors to retrieve. Utilizing a dataset provider, the node processes these inputs to return an array of nearest neighbors, each accompanied by its corresponding distance and data. This functionality is particularly useful in AI applications that require similarity searches, such as recommendation systems, clustering, or any scenario where proximity in a feature space is relevant."]},{"id":"t_l6-v7y5s9NcCgqZFlIW","data":["The Extract YAML Node in Rivet is designed to parse and extract data from YAML-formatted text input. It allows users to specify a root property name, which defaults to \"yamlDocument,\" and optionally provides an object path for more granular extraction of values within the YAML structure. The node processes the input string to locate the specified root property, extracts the corresponding YAML content, and converts it into a JavaScript object. If an object path is provided, it utilizes JSONPath to retrieve specific values, returning the parsed object, any matches found, or indicating if no match was made. This node is particularly useful for applications that need to handle and manipulate YAML data dynamically, enabling seamless integration of YAML parsing into AI agent workflows."]},{"id":"SwWZWPP7-L2NkcE_1X8mx","data":["The IfNode in Rivet serves as a conditional control flow mechanism within AI prompt chains, allowing users to route data based on the truthiness of a specified condition. It takes two inputs: a condition and a value, and based on the evaluation of the condition, it directs the value either to the True output or the False output. If the condition is truthy, the value is passed through the True port; if falsy, it is routed through the False port. This node is particularly useful for implementing decision-making logic in AI agents, enabling dynamic responses based on varying input conditions, and enhancing the overall flexibility and functionality of AI workflows."]}]}}]}